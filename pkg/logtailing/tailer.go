package logtailing

import (
	"encoding/json"
	"fmt"
	"io/ioutil"
	"os"
	"os/signal"
	"syscall"
	"time"

	"github.com/logrusorgru/aurora"
	log "github.com/sirupsen/logrus"

	"github.com/stripe/stripe-cli/pkg/ansi"
	"github.com/stripe/stripe-cli/pkg/stripeauth"
	"github.com/stripe/stripe-cli/pkg/websocket"
)

const outputFormatJSON = "json"

// LogFilters contains all of the potential user-provided filters for log tailing
type LogFilters struct {
	FilterIPAddress      string `json:"filter_ip_address,omitempty"`
	FilterHTTPMethod     string `json:"filter_http_method,omitempty"`
	FilterRequestPath    string `json:"filter_request_path,omitempty"`
	FilterSource         string `json:"filter_source,omitempty"`
	FilterStatusCode     string `json:"filter_status_code,omitempty"`
	FilterStatusCodeType string `json:"filter_status_code_type,omitempty"`
}

// Config provides the configuration of a log tailer
type Config struct {
	APIBaseURL string

	// DeviceName is the name of the device sent to Stripe to help identify the device
	DeviceName string

	// Filters for API request logs
	Filters *LogFilters

	// Key is the API key used to authenticate with Stripe
	Key string

	// Info, error, etc. logger. Unrelated to API request logs.
	Log *log.Logger

	// Force use of unencrypted ws:// protocol instead of wss://
	NoWSS bool

	// Output format for request logs
	OutputFormat string

	// WebSocketFeature is the feature specified for the websocket connection
	WebSocketFeature string
}

// Tailer is the main interface for running the log tailing session
type Tailer struct {
	cfg *Config

	stripeAuthClient *stripeauth.Client
	webSocketClient  *websocket.Client

	interruptCh chan os.Signal
}

// EventPayload is the mapping for fields in event payloads from request log tailing
type EventPayload struct {
	CreatedAt string `json:"created_at"`
	Method    string `json:"method"`
	RequestID string `json:"request_id"`
	Status    int    `json:"status"`
	URL       string `json:"url"`
}

// New creates a new Tailer
func New(cfg *Config) *Tailer {
	if cfg.Log == nil {
		cfg.Log = &log.Logger{Out: ioutil.Discard}
	}
	return &Tailer{
		cfg: cfg,
		stripeAuthClient: stripeauth.NewClient(cfg.Key, &stripeauth.Config{
			Log:        cfg.Log,
			APIBaseURL: cfg.APIBaseURL,
		}),
		interruptCh: make(chan os.Signal, 1),
	}
}

// Run sets the websocket connection
func (tailer *Tailer) Run() error {
	s := ansi.StartSpinner("Getting ready...", tailer.cfg.Log.Out)

	// Intercept Ctrl+c so we can do some clean up
	signal.Notify(tailer.interruptCh, os.Interrupt, syscall.SIGTERM)

	filters, err := jsonifyFilters(tailer.cfg.Filters)
	if err != nil {
		tailer.cfg.Log.Fatalf("Error while converting log filters to JSON encoding: %v", err)
	}

	session, err := tailer.stripeAuthClient.Authorize(tailer.cfg.DeviceName, tailer.cfg.WebSocketFeature, &filters)
	if err != nil {
		// TODO: better error handling / retries
		tailer.cfg.Log.Fatalf("Error while authenticating with Stripe: %v", err)
	}

	tailer.webSocketClient = websocket.NewClient(
		session.WebSocketURL,
		session.WebSocketID,
		session.WebSocketAuthorizedFeature,
		&websocket.Config{
			EventHandler:      websocket.EventHandlerFunc(tailer.processRequestLogEvent),
			Log:               tailer.cfg.Log,
			NoWSS:             tailer.cfg.NoWSS,
			ReconnectInterval: time.Duration(session.ReconnectDelay) * time.Second,
		},
	)
	go tailer.webSocketClient.Run()

	ansi.StopSpinner(s, "Ready! You're now waiting to receive API request logs (^C to quit)", tailer.cfg.Log.Out)

	// Block until Ctrl+C is received
	<-tailer.interruptCh

	log.WithFields(log.Fields{
		"prefix": "logs.Tailer.Run",
	}).Debug("Ctrl+C received, cleaning up...")

	if tailer.webSocketClient != nil {
		tailer.webSocketClient.Stop()
	}

	log.WithFields(log.Fields{
		"prefix": "logs.Tailer.Run",
	}).Debug("Bye!")

	return nil
}

func (tailer *Tailer) processRequestLogEvent(msg websocket.IncomingMessage) {
	if msg.RequestLogEvent == nil {
		tailer.cfg.Log.Warn("WebSocket specified for request logs received non-request-logs event")
		return
	}

	requestLogEvent := msg.RequestLogEvent

	tailer.cfg.Log.WithFields(log.Fields{
		"prefix":     "logs.Tailer.processRequestLogEvent",
		"webhook_id": requestLogEvent.RequestLogID,
	}).Debugf("Processing request log event")

	var payload EventPayload
	if err := json.Unmarshal([]byte(requestLogEvent.EventPayload), &payload); err != nil {
		tailer.cfg.Log.Warn("Received malformed payload: ", err)
	}

	// Don't show stripecli/sessions logs since they're generated by the CLI
	if payload.URL == "/v1/stripecli/sessions" {
		tailer.cfg.Log.Debug("Filtering out /v1/stripecli/sessions from logs")
		return
	}

	if tailer.cfg.OutputFormat == outputFormatJSON {
		fmt.Println(ansi.ColorizeJSON(requestLogEvent.EventPayload, os.Stdout))
		return
	}

	coloredStatus := colorizeStatus(payload.Status)

	url := fmt.Sprintf("https://dashboard.stripe.com/test/logs/%s", payload.RequestID)
	requestLink := ansi.Linkify(payload.RequestID, url, os.Stdout)

	if payload.URL == "" {
		payload.URL = "[View path in dashboard]"
	}

	outputStr := fmt.Sprintf("%s UTC [%d] %s %s %s", payload.CreatedAt, coloredStatus, payload.Method, payload.URL, requestLink)
	fmt.Println(outputStr)
}

func colorizeStatus(status int) aurora.Value {
	color := ansi.Color(os.Stdout)

	switch {
	case status >= 500:
		return color.Red(status).Bold()
	case status >= 400:
		return color.Yellow(status).Bold()
	default:
		return color.Green(status).Bold()
	}
}

func jsonifyFilters(logFilters *LogFilters) (string, error) {
	bytes, err := json.Marshal(logFilters)
	if err != nil {
		return "", err
	}

	jsonStr := string(bytes)
	return jsonStr, nil
}
